<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>mini-iobuf</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="preface.html">Preface</a></li><li class="chapter-item expanded affix "><a href="iobuf_design_goals.html">Design Goals of iobuf</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Implementation Details</li><li class="chapter-item expanded "><a href="temporary_buffer.html"><strong aria-hidden="true">1.</strong> Temporary Buffer</a></li><li class="chapter-item expanded "><a href="iobuf.html"><strong aria-hidden="true">2.</strong> IoBuf</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">mini-iobuf</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="motivation"><a class="header" href="#motivation">Motivation</a></h1>
<p>I recently came across the <a href="https://www.datadoghq.com/blog/engineering/introducing-glommio/">thread-per-core (TpC) architecture</a>. TpC is an architecture in which each application thread is pinned to a specific CPU and uses message passing instead of message sharing to share data. This architecture removes the need for expensive synchronization mechanisms such as locks and eliminates costly context switches.</p>
<p>I had some questions about memory management in TpC. If a core wants to share data with another core, does the source core need to copy data to the destination core each time? Isn’t that expensive?</p>
<p>This <a href="https://redpanda.com/blog/tpc-buffers">engineering blog</a> written by Redpanda answered my question. In the blog, Alexander Gallego talks about buffer management in a TpC environment. He introduced <code>iobuf</code>, Redpanda’s 0-copy buffer management for TpC which allows cores to share data without incurring a copy overhead.</p>
<p>To understand <code>iobuf</code> better, I studied <code>iobuf</code>'s source code and built a toy version of it in Rust. Full source code for my toy implementation, <code>mini-iobuf</code>, is available <a href="https://github.com/brianshih1/mini-iobuf">here</a>.</p>
<p>Also let me preface this by saying that I am a novice in the world of systems programming. So please let me know if I’m making any incorrect statements!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="design-goals-of-iobuf"><a class="header" href="#design-goals-of-iobuf">Design Goals of iobuf</a></h1>
<p>The <a href="https://redpanda.com/blog/tpc-buffers">Redpanda blog</a> says that iobuf is “Redpanda’s 0-copy buffer management for TpC”. Let’s summarize what they mean by that.</p>
<h3 id="thread-per-core"><a class="header" href="#thread-per-core">Thread-per-core</a></h3>
<p>Firstly, what even is TpC?</p>
<p>TpC is an programming model that address the two shortcomings of threaded programming:</p>
<ul>
<li>Threads executing on the same data requires synchronization mechanisms like locks, which are expensive.</li>
<li>Context switching is required when a thread suspends itself and lets another thread run. Context switching is expensive.</li>
</ul>
<p>In TpC, each application thread is pinned to a CPU. Since the OS cannot move the threads around, there are no context switches. Furthermore, the computer memory is sharded evenly across all cores. Each thread relies on message passing instead of shared memory to share information. This means that there are no locks in TpC.</p>
<p>To learn more about TpC, check out <a href="https://seastar.io/shared-nothing/">this article by Seastar</a> or this <a href="https://www.datadoghq.com/blog/engineering/introducing-glommio/">blog by Glommio</a>.</p>
<h3 id="sharing-data-between-cores"><a class="header" href="#sharing-data-between-cores">Sharing Data Between Cores</a></h3>
<p>Redpanda is a Kafka-compatible, streaming system built on top of a TpC architecture. Since Redpanda is a streaming system, there could be many clients (producer or consumer) connected to it at any time. There is no guarantee that the clients are connected to the core that owns the data.</p>
<p>Therefore, Redpanda needs an efficient way to share a view of the parsed messages across cores. In addition, Redpanda wants to deallocate data when none of the cores need it. These two requirements gave birth to <code>iobuf</code>, a “ref-counted, fragmented-buffer-chain with deferred deletes”.</p>
<p>Now, let's look at how it works under the hood by examining my toy implementation!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="temporary-buffer"><a class="header" href="#temporary-buffer">Temporary Buffer</a></h1>
<p>Before we implement the <code>iobuf</code>, we need to first implement its building block, the <code>Temporary Buffer</code>.</p>
<p>Temporary Buffer is a memory management abstraction for a contiguous region of memory. What makes temporary buffer different from buffers like <code>Vec</code> is that the underlying memory can be shared with another <code>temporary_buffer</code>. In other words, it is a buffer with automatic reference count, kind of like an <code>Arc</code> in Rust.</p>
<p>My implementation is largely inspired by Seastar’s <a href="https://github.com/scylladb/seastar/blob/e908cfce2d4488976f3b91906954f435aaa99238/include/seastar/core/temporary_buffer.hh">implementation</a>.</p>
<h2 id="api"><a class="header" href="#api">API</a></h2>
<p><strong>Constructor</strong></p>
<p>To create a <code>TemporaryBuffer</code>, you use the <code>new: (size: usize) -&gt; TemporaryBuffer</code> API.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let buffer = TemporaryBuffer::new(12);
<span class="boring">}</span></code></pre></pre>
<p><strong>Write</strong></p>
<p>To write into a <code>TemporaryBuffer</code>, you call <code>get_write(&amp;self) -&gt; Option&lt;*mut u8&gt;</code>. It is dangerous to return a <code>mutable raw pointer</code> if there is another reference to the <code>TemporaryBuffer</code> as the other buffer may not expect data to change. Therefore, <code>get_write</code> would return <code>None</code> if there are more than one references to the buffer.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let buffer = TemporaryBuffer::new(12);
let ptr = buffer.get_write().unwrap();
let data: Vec&lt;u8&gt; = vec![1, 2, 3];
unsafe {
    std::ptr::copy_nonoverlapping(data.as_ptr(), ptr, 3);
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Share</strong></p>
<p>To share a buffer, you can either use <code>share(&amp;self) -&gt; TemporaryBuffer</code> to share the entire buffer or <code>share_slice(&amp;self, pos: usize, len: usize) -&gt; TemporaryBuffer</code> to get a sliced reference to the temporary buffer.</p>
<p>Note that in either scenario, the underlying data will not be destroyed until all references to the buffer is destroyed. This means that having a tiny slice of a temporary buffer would result in the entire data the original temporary buffer holds to be held in memory.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let buffer = TemporaryBuffer::new(12);
	{
	    let second = buffer.share();
	    assert_eq!(buffer.get_ref_count(), 2);
	
	    {
	        let slice = buffer.share_slice(0, 3);
	        assert_eq!(buffer.get_ref_count(), 3);
	    }
	}
assert_eq!(buffer.get_ref_count(), 1);
<span class="boring">}</span></code></pre></pre>
<p>In the example above, we created multiple references to the <code>buffer</code> in different scopes. In the deepest scope, the reference count for the <code>buffer</code> is 3. But in the outmost scope, since the scoped references get dropped, there is only 1 ref count.</p>
<h2 id="internals"><a class="header" href="#internals">Internals</a></h2>
<p>Conceptually, a <code>temporary_buffer</code> is quite similar to an <code>Arc</code>. Instead of <code>Arc::clone</code>, you perform <code>share</code> or <code>share_slice</code> to increment the ref count. When the reference count reaches 0, the underlying data is deallocated.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct TemporaryBuffer {
    deleter: NonNull&lt;BufferInternal&gt;,
    size: usize,
    buffer: *mut u8,
}

struct BufferInternal {
    ref_counter: AtomicUsize,
    size: usize,
    buffer: *mut u8,
}
<span class="boring">}</span></code></pre></pre>
<p>This is what the <code>TemporaryBuffer</code> looks like under the hood:</p>
<p>Each <code>TemporaryBuffer</code> has a <code>NonNull</code> raw pointer to a <code>BufferInternal</code>. <code>BufferInternal</code> keeps track of the reference counts and deallocates the memory when the reference count reaches 0.</p>
<p>This is the implementation for the constructor:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn new(size: usize) -&gt; Self {
    let layout = Layout::array::&lt;u8&gt;(size).unwrap();
    let buffer = unsafe { alloc(layout) };
    TemporaryBuffer {
        deleter: NonNull::from(Box::leak(Box::new(BufferInternal {
            ref_counter: AtomicUsize::new(1),
            size,
            buffer,
        }))),
        size,
        buffer,
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Here, we used <code>Box::new</code> to create a new allocation and <code>Box::leak</code> to give up ownership of the value without deallocating the memory associated with it. Then we use <code>NonNull</code> to get the pointer to the memory.</p>
<p>This is the implementation of <code>share_slice</code>. Each time it’s called, the <code>deleter</code>'s <code>ref_count</code> is incremented by one. We can use <code>Relaxed</code> memory ordering here because</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn share_slice(&amp;self, pos: usize, len: usize) -&gt; TemporaryBuffer {
    if self.get_deleter().ref_count.fetch_add(1, Relaxed) &gt; usize::MAX / 2 {
        std::process::abort();
    }
    TemporaryBuffer {
        deleter: self.deleter,
        size: len,
        buffer: unsafe { self.buffer.add(pos) },
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Just as we increment the ref count when sharing the buffer, we decrement the ref count (with <code>fetch_sub</code> when the buffer gets dropped (i.e. out of scope).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Drop for TemporaryBuffer {
    fn drop(&amp;mut self) {
        if self.get_deleter().ref_count.fetch_sub(1, Release) == 1 {
            fence(Acquire);
            unsafe {
                let layout = Layout::array::&lt;u8&gt;(self.deleter.as_ref().size).unwrap();
                dealloc(self.deleter.as_ref().buffer, layout);
                drop(Box::from_raw(self.deleter.as_ptr()));
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>If <code>fetch_sub</code> returns 1, we need to ensure that no other references have access to the underlying memory. Note that this isn’t trivial as the <code>buffer</code> is not part of the <code>atomic</code> ref_count. To guarantee that any non-atomic loads and stores to buffer occur before the final <code>fetch_sub</code>, we need to establish a <code>happens-before relationship</code> between the final <code>fetch_sub</code> and all other <code>fetch_subs</code>.</p>
<img src="./assets/fence.png" width="85%">
<p>The figure above illustrates how we establish the happens-before relationship. Note that all atomic operations (even relaxed ones) have total modification order for that atomic variable. This means that all modifications of the same atomic variable happen in an order that is the same from the perspective of every single thread. This means that if <code>fetch_sub</code> returns <code>1</code>, it is the last <code>fetch_sub</code>.</p>
<p>We use a an <code>acquire fence</code> to guarantee that whatever happens after the fence happens after any event before all other <code>final_sub</code>s. Since loads or modifications to the <code>buffer</code> counts as <code>any event</code>, we guarantee that after the fence, no other threads have access to the underlying memory.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iobuf"><a class="header" href="#iobuf">IoBuf</a></h1>
<p>My toy <code>iobuf</code> implementation is based on <code>Redpanda</code>'s <code>iobuf</code> <a href="https://github.com/redpanda-data/redpanda/blob/28b5c47fb4d2d23322622e1ba52f973179ba504e/src/v/bytes/iobuf.h#L31">implementation</a>.</p>
<p>Iobuf is pretty much just a linked list of <code>TemporaryBuffer</code>s. Each <code>Temporary Buffer</code> is wrapped around an <code>IoFragment</code>, which is like a linked list node with next/prev pointers to other fragments.</p>
<img src="./assets/iobuf.png" width="85%">
<h3 id="api-1"><a class="header" href="#api-1">API</a></h3>
<p><strong>Constructor</strong></p>
<p>There are a few different ways to create an <code>iobuf</code>. The easiest way is to just use the <code>new() -&gt; Iobuf</code> as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut iobuf = IoBuf::new();
<span class="boring">}</span></code></pre></pre>
<p><strong>Append</strong></p>
<p>There are a few different ways to <code>append</code> data to an <code>iobuf</code>. Here are some of the method signatures to append:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn append(&amp;mut self, src: *const u8, len: usize) -&gt; ();
fn append_temporary_buffer(&amp;mut self, buffer: TemporaryBuffer);
fn append_fragment(&amp;mut self, fragment: IoFragment);
<span class="boring">}</span></code></pre></pre>
<p><strong>Iterator</strong></p>
<p>To create an iterator over the <code>IoFragment</code>s that make up the <code>iobuf</code>, you can call the <code>begin()</code> method with the signature: <code>fn begin&lt;'a&gt;(&amp;'a self) -&gt; IoFragmentIter&lt;'a&gt;</code>.</p>
<p>I’ll go deeper into iterators in the next page where I talk about <code>IoIteratorConsumer</code>.</p>
<h3 id="internals-1"><a class="header" href="#internals-1">Internals</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct IoBuf {
    frags: LinkedList&lt;IoFragmentAdapter&gt;,
    // number of bytes the IoBuf contains
    size: usize,
}
<span class="boring">}</span></code></pre></pre>
<p>As we can see from the definition of <code>IoBuf</code>, it’s pretty much just a linked list of <code>IoFragment</code> nodes. The <code>IoBuf</code> itself doesn’t store any data, it just holds pointers to <code>temporary buffer</code> instances, which actually hold the data.</p>
<p>Similar to Redpanda’s implementation, I also used an intrusive linked list from the <a href="https://amanieu.github.io/intrusive-rs/intrusive_collections/linked_list/index.html">intrusive_collections trait</a>.</p>
<p>The main difference between an intrusive collection and a normal collection is that intrusive collections don’t allocate memory themselves. This means that the <code>next</code> and <code>prev</code> pointers directly live inside the nodes. Intrusive collections are good because it eliminates dynamic memory allocation, which may cause the memory pools to be fragmented.</p>
<p>To work with the intrusive linked list, I just needed to use the <code>intrusive_adapter</code> macro like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>intrusive_adapter!(pub IoFragmentAdapter = Box&lt;IoFragment&gt;: IoFragment { link: LinkedListLink });
<span class="boring">}</span></code></pre></pre>
<p>The macro automatically creates an <code>IoFragmentAdapter</code> with <code>next</code> and <code>prev</code> pointers. <code>IoFragmentAdapter</code> is the actual linked list node the <code>iobuf</code> uses.</p>
<p>The actual definition of <code>IoFragment</code> is:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct IoFragment {
    used_bytes: RefCell&lt;usize&gt;,
    buf: TemporaryBuffer,
    pub link: LinkedListLink,
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Append</strong></p>
<p>Let’s look at how we implement <code>fn append(&amp;mut self, src: *const u8, len: usize) -&gt; ();</code></p>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/64cc878f-92cd-43af-8899-715264a70c70/Screenshot_2023-07-19_at_5.41.58_PM.png" alt="Screenshot 2023-07-19 at 5.41.58 PM.png" /></p>
<p>The diagram shows an <code>iobuf</code> with 2 fragments. The second fragment has <code>10</code> available bytes. If we insert <code>15</code> bytes into the <code>iobuf</code>, it will first fill in the available bytes. Then it will create a new <code>io_fragment</code> with the next allocation size and fill the remaining <code>5</code> bytes into the next fragment.</p>
<p>Computing the next allocation size is based on the <a href="https://github.com/redpanda-data/redpanda/blob/28b5c47fb4d2d23322622e1ba52f973179ba504e/src/v/bytes/details/io_allocation_size.h#L32">iobuf allocation table logic provided by Redpanda</a>. In general, fixed sizing and size capping help reduce memory fragmentation.</p>
<p>Here is the implementation of <code>append</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn append(&amp;mut self, src: *const u8, len: usize) -&gt; () {
        if len &lt;= self.available_bytes() {
            let fragment = self.get_last_fragment();
            self.size += fragment.append(src, len);
            return;
        }
        let mut remaining = len;
        let mut ptr = src;
        while remaining &gt; 0 {
            self.append_new_fragment(remaining);
            let appended_size = self.get_last_fragment().append(ptr, remaining);
            ptr = unsafe { ptr.add(appended_size) };
            remaining -= appended_size;
            self.size += appended_size;
        }
    }
<span class="boring">}</span></code></pre></pre>
<p><strong>Share</strong></p>
<p>Sharing an <code>iobuf</code> based on a <code>pos</code> and a <code>len</code> simply creates a new <code>iobuf</code> and find the <code>io_fragment</code>s that intersect with the share range. If it is, we use the <code>temporary_buffer</code>'s <code>share</code> method to get a reference of the temporary buffer.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn share(&amp;self, pos: usize, len: usize) -&gt; IoBuf {
        let mut ret = IoBuf::new();
        let mut remaining = len;
        let mut pos = pos;
        for fragment in self.frags.iter() {
            if remaining == 0 {
                return ret;
            }
            if pos &gt;= fragment.size() {
                pos -= fragment.size();
                continue;
            }

            let right = std::cmp::min(pos + remaining, fragment.size() - 1);
            let buffer = fragment.share(pos, right);
            ret.append_temporary_buffer(buffer);
            remaining -= right - pos - 1;
        }
        ret
    }
<span class="boring">}</span></code></pre></pre>
<p>In other words, <code>share</code> increments the reference count of each of the temporary buffers that it intersects. When the <code>iobuf</code> drops, all the reference counts of the temporary buffers drop. Each temporary buffer is responsible for deallocating the memory if the reference count reaches zero.</p>
<h3 id="ioiteratorconsumer"><a class="header" href="#ioiteratorconsumer">IoIteratorConsumer</a></h3>
<p>To get data out of an <code>iobuf</code>, the best way is to use a consumer iterator. My <code>IoIteratorConsumer</code> implementation is based on Redpanda’s implementation. Check out their source code <a href="https://github.com/redpanda-data/redpanda/blob/28b5c47fb4d2d23322622e1ba52f973179ba504e/src/v/bytes/details/io_iterator_consumer.h#L47">here</a>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut iobuf = IoBuf::new();
let values1 = generate_random_u8_vec(1000);
iobuf.append(values1.as_ptr(), values1.len());

let values2 = generate_random_u8_vec(3000);
iobuf.append(values2.as_ptr(), values2.len());

let mut consumer = IoIteratorConsumer::new(iobuf.begin());
let arr = consumer.consume_to_arr(1000);
assert_eq!(values1, arr);

let arr2 = consumer.consume_to_arr(3000);
assert_eq!(values2, arr2);
<span class="boring">}</span></code></pre></pre>
<p>This example showcases how the <code>IoIteratorConsumer</code> is used. You initialize it with a pointer to an <code>IoFragmentIter</code>. You then invoke <code>consumer_to_arr</code> to copy the data into an array. Note that each call to <code>consume_to_arr</code> would advance the iterator pointer under the hood.</p>
<p>The method <code>consume_to_arr</code> is actually powered by the <code>consume</code> method, which takes a callback with the start pointer and the size.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn consume&lt;T&gt;(&amp;mut self, n: usize, consumer: T)
    where
        T: Fn(*const u8, usize) -&gt; (),
    {
        let mut consumed = 0;
        while self.current_frag.is_some() &amp;&amp; consumed &lt; n {
            let segment_bytes_left = self.segment_bytes_left();

            if segment_bytes_left == 0 {
                self.current_frag = self.frag_it.next();
                self.frag_index = self.current_frag.map(|frag| frag.get_start());
                continue;
            }
            let step = std::cmp::min(segment_bytes_left, n - consumed);
            let frag_index = self.frag_index.unwrap();
            consumer(frag_index, step);
            self.frag_index = Some(unsafe { frag_index.add(step) });
            consumed += step;
        }
    }
<span class="boring">}</span></code></pre></pre>
<p>The algorithm basically iterates over the fragments and calling callbacks with the start pointer and the size in that fragment to consume. Once the number of elements that have been consumed reaches n, the iterator stops.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
