<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Temporary Buffer - mini-iobuf</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="preface.html">Preface</a></li><li class="chapter-item expanded affix "><a href="iobuf_design_goals.html">Design Goals of iobuf</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Implementation Details</li><li class="chapter-item expanded "><a href="temporary_buffer.html" class="active"><strong aria-hidden="true">1.</strong> Temporary Buffer</a></li><li class="chapter-item expanded "><a href="iobuf.html"><strong aria-hidden="true">2.</strong> IoBuf</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">mini-iobuf</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="temporary-buffer"><a class="header" href="#temporary-buffer">Temporary Buffer</a></h1>
<p>Before we implement the <code>iobuf</code>, we need to first implement its building block, the <code>Temporary Buffer</code>.</p>
<p>Temporary Buffer is a memory management abstraction for a contiguous region of memory. What makes temporary buffer different from buffers like <code>Vec</code> is that the underlying memory can be shared with another <code>temporary_buffer</code>. In other words, it is a buffer with automatic reference count, kind of like an <code>Arc</code> in Rust.</p>
<p>My implementation is largely inspired by Seastarâ€™s <a href="https://github.com/scylladb/seastar/blob/e908cfce2d4488976f3b91906954f435aaa99238/include/seastar/core/temporary_buffer.hh">implementation</a>.</p>
<h2 id="api"><a class="header" href="#api">API</a></h2>
<p><strong>Constructor</strong></p>
<p>To create a <code>TemporaryBuffer</code>, you use the <code>new: (size: usize) -&gt; TemporaryBuffer</code> API.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let buffer = TemporaryBuffer::new(12);
<span class="boring">}</span></code></pre></pre>
<p><strong>Write</strong></p>
<p>To write into a <code>TemporaryBuffer</code>, you call <code>get_write(&amp;self) -&gt; Option&lt;*mut u8&gt;</code>. It is dangerous to return a <code>mutable raw pointer</code> if there is another reference to the <code>TemporaryBuffer</code> as the other buffer may not expect data to change. Therefore, <code>get_write</code> would return <code>None</code> if there are more than one references to the buffer.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let buffer = TemporaryBuffer::new(12);
let ptr = buffer.get_write().unwrap();
let data: Vec&lt;u8&gt; = vec![1, 2, 3];
unsafe {
    std::ptr::copy_nonoverlapping(data.as_ptr(), ptr, 3);
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Share</strong></p>
<p>To share a buffer, you can either use <code>share(&amp;self) -&gt; TemporaryBuffer</code> to share the entire buffer or <code>share_slice(&amp;self, pos: usize, len: usize) -&gt; TemporaryBuffer</code> to get a sliced reference to the temporary buffer.</p>
<p>Note that in either scenario, the underlying data will not be destroyed until all references to the buffer is destroyed. This means that having a tiny slice of a temporary buffer would result in the entire data the original temporary buffer holds to be held in memory.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let buffer = TemporaryBuffer::new(12);
	{
	    let second = buffer.share();
	    assert_eq!(buffer.get_ref_count(), 2);
	
	    {
	        let slice = buffer.share_slice(0, 3);
	        assert_eq!(buffer.get_ref_count(), 3);
	    }
	}
assert_eq!(buffer.get_ref_count(), 1);
<span class="boring">}</span></code></pre></pre>
<p>In the example above, we created multiple references to the <code>buffer</code> in different scopes. In the deepest scope, the reference count for the <code>buffer</code> is 3. But in the outmost scope, since the scoped references get dropped, there is only 1 ref count.</p>
<h2 id="internals"><a class="header" href="#internals">Internals</a></h2>
<p>Conceptually, a <code>temporary_buffer</code> is quite similar to an <code>Arc</code>. Instead of <code>Arc::clone</code>, you perform <code>share</code> or <code>share_slice</code> to increment the ref count. When the reference count reaches 0, the underlying data is deallocated.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct TemporaryBuffer {
    deleter: NonNull&lt;BufferInternal&gt;,
    size: usize,
    buffer: *mut u8,
}

struct BufferInternal {
    ref_counter: AtomicUsize,
    size: usize,
    buffer: *mut u8,
}
<span class="boring">}</span></code></pre></pre>
<p>This is what the <code>TemporaryBuffer</code> looks like under the hood:</p>
<p>Each <code>TemporaryBuffer</code> has a <code>NonNull</code> raw pointer to a <code>BufferInternal</code>. <code>BufferInternal</code> keeps track of the reference counts and deallocates the memory when the reference count reaches 0.</p>
<p>This is the implementation for the constructor:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn new(size: usize) -&gt; Self {
    let layout = Layout::array::&lt;u8&gt;(size).unwrap();
    let buffer = unsafe { alloc(layout) };
    TemporaryBuffer {
        deleter: NonNull::from(Box::leak(Box::new(BufferInternal {
            ref_counter: AtomicUsize::new(1),
            size,
            buffer,
        }))),
        size,
        buffer,
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Here, we used <code>Box::new</code> to create a new allocation and <code>Box::leak</code> to give up ownership of the value without deallocating the memory associated with it. Then we use <code>NonNull</code> to get the pointer to the memory.</p>
<p>This is the implementation of <code>share_slice</code>. Each time itâ€™s called, the <code>deleter</code>'s <code>ref_count</code> is incremented by one. We can use <code>Relaxed</code> memory ordering here because</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn share_slice(&amp;self, pos: usize, len: usize) -&gt; TemporaryBuffer {
    if self.get_deleter().ref_count.fetch_add(1, Relaxed) &gt; usize::MAX / 2 {
        std::process::abort();
    }
    TemporaryBuffer {
        deleter: self.deleter,
        size: len,
        buffer: unsafe { self.buffer.add(pos) },
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Just as we increment the ref count when sharing the buffer, we decrement the ref count (with <code>fetch_sub</code> when the buffer gets dropped (i.e. out of scope).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Drop for TemporaryBuffer {
    fn drop(&amp;mut self) {
        if self.get_deleter().ref_count.fetch_sub(1, Release) == 1 {
            fence(Acquire);
            unsafe {
                let layout = Layout::array::&lt;u8&gt;(self.deleter.as_ref().size).unwrap();
                dealloc(self.deleter.as_ref().buffer, layout);
                drop(Box::from_raw(self.deleter.as_ptr()));
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>If <code>fetch_sub</code> returns 1, we need to ensure that no other references have access to the underlying memory. Note that this isnâ€™t trivial as the <code>buffer</code> is not part of the <code>atomic</code> ref_count. To guarantee that any non-atomic loads and stores to buffer occur before the final <code>fetch_sub</code>, we need to establish a <code>happens-before relationship</code> between the final <code>fetch_sub</code> and all other <code>fetch_subs</code>.</p>
<img src="./assets/fence.png" width="85%">
<p>The figure above illustrates how we establish the happens-before relationship. Note that all atomic operations (even relaxed ones) have total modification order for that atomic variable. This means that all modifications of the same atomic variable happen in an order that is the same from the perspective of every single thread. This means that if <code>fetch_sub</code> returns <code>1</code>, it is the last <code>fetch_sub</code>.</p>
<p>We use a an <code>acquire fence</code> to guarantee that whatever happens after the fence happens after any event before all other <code>final_sub</code>s. Since loads or modifications to the <code>buffer</code> counts as <code>any event</code>, we guarantee that after the fence, no other threads have access to the underlying memory.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="iobuf_design_goals.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="iobuf.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="iobuf_design_goals.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="iobuf.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
