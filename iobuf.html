<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>IoBuf - mini-iobuf</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="preface.html">Preface</a></li><li class="chapter-item expanded affix "><a href="iobuf_design_goals.html">Design Goals of iobuf</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Implementation Details</li><li class="chapter-item expanded "><a href="temporary_buffer.html"><strong aria-hidden="true">1.</strong> Temporary Buffer</a></li><li class="chapter-item expanded "><a href="iobuf.html" class="active"><strong aria-hidden="true">2.</strong> IoBuf</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">mini-iobuf</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="iobuf"><a class="header" href="#iobuf">IoBuf</a></h1>
<p>My toy <code>iobuf</code> implementation is based on <code>Redpanda</code>'s <code>iobuf</code> <a href="https://github.com/redpanda-data/redpanda/blob/28b5c47fb4d2d23322622e1ba52f973179ba504e/src/v/bytes/iobuf.h#L31">implementation</a>.</p>
<p>Iobuf is pretty much just a linked list of <code>TemporaryBuffer</code>s. Each <code>Temporary Buffer</code> is wrapped around an <code>IoFragment</code>, which is like a linked list node with next/prev pointers to other fragments.</p>
<img src="./assets/iobuf.png" width="85%">
<h3 id="api"><a class="header" href="#api">API</a></h3>
<p><strong>Constructor</strong></p>
<p>There are a few different ways to create an <code>iobuf</code>. The easiest way is to just use the <code>new() -&gt; Iobuf</code> as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut iobuf = IoBuf::new();
<span class="boring">}</span></code></pre></pre>
<p><strong>Append</strong></p>
<p>There are a few different ways to <code>append</code> data to an <code>iobuf</code>. Here are some of the method signatures to append:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn append(&amp;mut self, src: *const u8, len: usize) -&gt; ();
fn append_temporary_buffer(&amp;mut self, buffer: TemporaryBuffer);
fn append_fragment(&amp;mut self, fragment: IoFragment);
<span class="boring">}</span></code></pre></pre>
<p><strong>Iterator</strong></p>
<p>To create an iterator over the <code>IoFragment</code>s that make up the <code>iobuf</code>, you can call the <code>begin()</code> method with the signature: <code>fn begin&lt;'a&gt;(&amp;'a self) -&gt; IoFragmentIter&lt;'a&gt;</code>.</p>
<p>I’ll go deeper into iterators in the next page where I talk about <code>IoIteratorConsumer</code>.</p>
<h3 id="internals"><a class="header" href="#internals">Internals</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct IoBuf {
    frags: LinkedList&lt;IoFragmentAdapter&gt;,
    // number of bytes the IoBuf contains
    size: usize,
}
<span class="boring">}</span></code></pre></pre>
<p>As we can see from the definition of <code>IoBuf</code>, it’s pretty much just a linked list of <code>IoFragment</code> nodes. The <code>IoBuf</code> itself doesn’t store any data, it just holds pointers to <code>temporary buffer</code> instances, which actually hold the data.</p>
<p>Similar to Redpanda’s implementation, I also used an intrusive linked list from the <a href="https://amanieu.github.io/intrusive-rs/intrusive_collections/linked_list/index.html">intrusive_collections trait</a>.</p>
<p>The main difference between an intrusive collection and a normal collection is that intrusive collections don’t allocate memory themselves. This means that the <code>next</code> and <code>prev</code> pointers directly live inside the nodes. Intrusive collections are good because it eliminates dynamic memory allocation, which may cause the memory pools to be fragmented.</p>
<p>To work with the intrusive linked list, I just needed to use the <code>intrusive_adapter</code> macro like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>intrusive_adapter!(pub IoFragmentAdapter = Box&lt;IoFragment&gt;: IoFragment { link: LinkedListLink });
<span class="boring">}</span></code></pre></pre>
<p>The macro automatically creates an <code>IoFragmentAdapter</code> with <code>next</code> and <code>prev</code> pointers. <code>IoFragmentAdapter</code> is the actual linked list node the <code>iobuf</code> uses.</p>
<p>The actual definition of <code>IoFragment</code> is:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct IoFragment {
    used_bytes: RefCell&lt;usize&gt;,
    buf: TemporaryBuffer,
    pub link: LinkedListLink,
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Append</strong></p>
<p>Let’s look at how we implement <code>fn append(&amp;mut self, src: *const u8, len: usize) -&gt; ();</code></p>
<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/64cc878f-92cd-43af-8899-715264a70c70/Screenshot_2023-07-19_at_5.41.58_PM.png" alt="Screenshot 2023-07-19 at 5.41.58 PM.png" /></p>
<p>The diagram shows an <code>iobuf</code> with 2 fragments. The second fragment has <code>10</code> available bytes. If we insert <code>15</code> bytes into the <code>iobuf</code>, it will first fill in the available bytes. Then it will create a new <code>io_fragment</code> with the next allocation size and fill the remaining <code>5</code> bytes into the next fragment.</p>
<p>Computing the next allocation size is based on the <a href="https://github.com/redpanda-data/redpanda/blob/28b5c47fb4d2d23322622e1ba52f973179ba504e/src/v/bytes/details/io_allocation_size.h#L32">iobuf allocation table logic provided by Redpanda</a>. In general, fixed sizing and size capping help reduce memory fragmentation.</p>
<p>Here is the implementation of <code>append</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn append(&amp;mut self, src: *const u8, len: usize) -&gt; () {
        if len &lt;= self.available_bytes() {
            let fragment = self.get_last_fragment();
            self.size += fragment.append(src, len);
            return;
        }
        let mut remaining = len;
        let mut ptr = src;
        while remaining &gt; 0 {
            self.append_new_fragment(remaining);
            let appended_size = self.get_last_fragment().append(ptr, remaining);
            ptr = unsafe { ptr.add(appended_size) };
            remaining -= appended_size;
            self.size += appended_size;
        }
    }
<span class="boring">}</span></code></pre></pre>
<p><strong>Share</strong></p>
<p>Sharing an <code>iobuf</code> based on a <code>pos</code> and a <code>len</code> simply creates a new <code>iobuf</code> and find the <code>io_fragment</code>s that intersect with the share range. If it is, we use the <code>temporary_buffer</code>'s <code>share</code> method to get a reference of the temporary buffer.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn share(&amp;self, pos: usize, len: usize) -&gt; IoBuf {
        let mut ret = IoBuf::new();
        let mut remaining = len;
        let mut pos = pos;
        for fragment in self.frags.iter() {
            if remaining == 0 {
                return ret;
            }
            if pos &gt;= fragment.size() {
                pos -= fragment.size();
                continue;
            }

            let right = std::cmp::min(pos + remaining, fragment.size() - 1);
            let buffer = fragment.share(pos, right);
            ret.append_temporary_buffer(buffer);
            remaining -= right - pos - 1;
        }
        ret
    }
<span class="boring">}</span></code></pre></pre>
<p>In other words, <code>share</code> increments the reference count of each of the temporary buffers that it intersects. When the <code>iobuf</code> drops, all the reference counts of the temporary buffers drop. Each temporary buffer is responsible for deallocating the memory if the reference count reaches zero.</p>
<h3 id="ioiteratorconsumer"><a class="header" href="#ioiteratorconsumer">IoIteratorConsumer</a></h3>
<p>To get data out of an <code>iobuf</code>, the best way is to use a consumer iterator. My <code>IoIteratorConsumer</code> implementation is based on Redpanda’s implementation. Check out their source code <a href="https://github.com/redpanda-data/redpanda/blob/28b5c47fb4d2d23322622e1ba52f973179ba504e/src/v/bytes/details/io_iterator_consumer.h#L47">here</a>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut iobuf = IoBuf::new();
let values1 = generate_random_u8_vec(1000);
iobuf.append(values1.as_ptr(), values1.len());

let values2 = generate_random_u8_vec(3000);
iobuf.append(values2.as_ptr(), values2.len());

let mut consumer = IoIteratorConsumer::new(iobuf.begin());
let arr = consumer.consume_to_arr(1000);
assert_eq!(values1, arr);

let arr2 = consumer.consume_to_arr(3000);
assert_eq!(values2, arr2);
<span class="boring">}</span></code></pre></pre>
<p>This example showcases how the <code>IoIteratorConsumer</code> is used. You initialize it with a pointer to an <code>IoFragmentIter</code>. You then invoke <code>consumer_to_arr</code> to copy the data into an array. Note that each call to <code>consume_to_arr</code> would advance the iterator pointer under the hood.</p>
<p>The method <code>consume_to_arr</code> is actually powered by the <code>consume</code> method, which takes a callback with the start pointer and the size.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn consume&lt;T&gt;(&amp;mut self, n: usize, consumer: T)
    where
        T: Fn(*const u8, usize) -&gt; (),
    {
        let mut consumed = 0;
        while self.current_frag.is_some() &amp;&amp; consumed &lt; n {
            let segment_bytes_left = self.segment_bytes_left();

            if segment_bytes_left == 0 {
                self.current_frag = self.frag_it.next();
                self.frag_index = self.current_frag.map(|frag| frag.get_start());
                continue;
            }
            let step = std::cmp::min(segment_bytes_left, n - consumed);
            let frag_index = self.frag_index.unwrap();
            consumer(frag_index, step);
            self.frag_index = Some(unsafe { frag_index.add(step) });
            consumed += step;
        }
    }
<span class="boring">}</span></code></pre></pre>
<p>The algorithm basically iterates over the fragments and calling callbacks with the start pointer and the size in that fragment to consume. Once the number of elements that have been consumed reaches n, the iterator stops.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="temporary_buffer.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="temporary_buffer.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
